// Wrapper around golang.org/x/crypto/nacl/box for easy use with KeyLength-byte keys
package keybox

import (
	cryptoRand "crypto/rand"
	"encoding/hex"
	"fmt"
	"io"

	"golang.org/x/crypto/curve25519"
	"golang.org/x/crypto/nacl/box"

	"github.com/bsn-si/IPEHR-gateway/src/pkg/errors"
)

const (
	KeyLength   = 32
	NonceLength = 24
)

type BoxKey [KeyLength]byte

// Encrypt encrypts message using SealAnonymous of nacl/box with PublicKey
func (b BoxKey) Encrypt(msg []byte) ([]byte, error) {
	publicKey := (*[KeyLength]byte)(&b)

	return SealAnonymous(msg, publicKey)
}

// Decrypt decrypts encrypted message using OpenAnonymous of nacl/box with PrivateKey
// and related PublicKey
func (b BoxKey) Decrypt(encrypted []byte) ([]byte, error) {
	privateKey := (*[KeyLength]byte)(&b)
	publicKey := new([32]byte)
	curve25519.ScalarBaseMult(publicKey, privateKey)

	return OpenAnonymous(encrypted, publicKey, privateKey)
}

func (b BoxKey) String() string {
	return hex.EncodeToString(b[:])
}

// GenerateKey generates a new public/private key pair suitable for use with
// Seal and Open
func GenerateKey() (publicKey, privateKey BoxKey) {
	pubKey, privKey, err := box.GenerateKey(cryptoRand.Reader)
	if err != nil {
		panic(err)
	}

	return BoxKey(*pubKey), BoxKey(*privKey)
}

// Precompute calculates the shared key between peersPublicKey and privateKey
// and writes it to sharedKey. The shared key can be used with
// OpenAfterPrecomputation and SealAfterPrecomputation to speed up processing
// when using the same pair of keys repeatedly.
func Precompute(sharedKey, peersPublicKey, privateKey *[KeyLength]byte) {
	box.Precompute(sharedKey, peersPublicKey, privateKey)
}

// Seal returns an encrypted and authenticated copy of message.
func Seal(message []byte, peersPublicKey, privateKey *[KeyLength]byte) ([]byte, error) {
	nonce, err := GenerateNonce()
	if err != nil {
		return []byte{}, err
	}

	return box.Seal(nonce[:], message, nonce, peersPublicKey, privateKey), nil
}

// SealAfterPrecomputation performs the same actions as Seal, but takes a
// shared key as generated by Precompute.
func SealAfterPrecomputation(message []byte, sharedKey *[KeyLength]byte) ([]byte, error) {
	nonce, err := GenerateNonce()
	if err != nil {
		return []byte{}, err
	}

	return box.SealAfterPrecomputation(nonce[:], message, nonce, sharedKey), nil
}

// SealAnonymous returns an encrypted and authenticated copy of message,
// This differs from Seal in that the sender is not required to provide
// a private key.
func SealAnonymous(message []byte, publicKey *[KeyLength]byte) ([]byte, error) {
	return box.SealAnonymous(nil, message, publicKey, nil)
}

// Open authenticates and decrypts a message produced by Seal
func Open(encrypted []byte, peersPublicKey, privateKey *[KeyLength]byte) ([]byte, error) {
	var decryptNonce [NonceLength]byte

	copy(decryptNonce[:], encrypted[:NonceLength])

	decrypted, ok := box.Open(nil, encrypted[NonceLength:], &decryptNonce, peersPublicKey, privateKey)
	if !ok {
		return []byte{}, fmt.Errorf("%w: decryption error", errors.ErrEncryption)
	}

	return decrypted, nil
}

// OpenAfterPrecomputation performs the same actions as Open, but takes a
// shared key as generated by Precompute.
func OpenAfterPrecomputation(encrypted []byte, sharedKey *[KeyLength]byte) ([]byte, error) {
	var decryptNonce [NonceLength]byte

	copy(decryptNonce[:], encrypted[:NonceLength])

	decrypted, ok := box.OpenAfterPrecomputation(nil, encrypted[NonceLength:], &decryptNonce, sharedKey)
	if !ok {
		return []byte{}, fmt.Errorf("%w: precomputed Decryption error", errors.ErrEncryption)
	}

	return decrypted, nil
}

// OpenAnonymous authenticates and decrypts a message produced by SealAnonymous
func OpenAnonymous(encrypted []byte, publicKey, privateKey *[KeyLength]byte) ([]byte, error) {
	decrypted, ok := box.OpenAnonymous(nil, encrypted, publicKey, privateKey)
	if !ok {
		return []byte{}, fmt.Errorf("%w: anonymous decryption error", errors.ErrEncryption)
	}

	return decrypted, nil
}

// Generate random nonce to use with Seal*
func GenerateNonce() (*[NonceLength]byte, error) {
	var nonce [NonceLength]byte

	if _, err := io.ReadFull(cryptoRand.Reader, nonce[:]); err != nil {
		return &nonce, err
	}

	return &nonce, nil
}
